import{j as u}from"./jsx-runtime-BeSPE4Ym.js";import"./iframe-JKkGDdHu.js";const S=e=>typeof e=="function",_=function(e,n){if(typeof e=="function")return function(){return e(arguments)?n.apply(this,arguments):t=>n(t,...arguments)};switch(e){case 0:case 1:throw new RangeError(`Invalid arity ${e}`);case 2:return function(t,r){return arguments.length>=2?n(t,r):function(o){return n(o,t)}};case 3:return function(t,r,o){return arguments.length>=3?n(t,r,o):function(a){return n(a,t,r)}};case 4:return function(t,r,o,a){return arguments.length>=4?n(t,r,o,a):function(p){return n(p,t,r,o)}};case 5:return function(t,r,o,a,p){return arguments.length>=5?n(t,r,o,a,p):function(s){return n(s,t,r,o,a)}};default:return function(){if(arguments.length>=e)return n.apply(this,arguments);const t=arguments;return function(r){return n(r,...t)}}}};function i(e,n,t,r,o,a,p,s,l){switch(arguments.length){case 1:return e;case 2:return n(e);case 3:return t(n(e));case 4:return r(t(n(e)));case 5:return o(r(t(n(e))));case 6:return a(o(r(t(n(e)))));case 7:return p(a(o(r(t(n(e))))));case 8:return s(p(a(o(r(t(n(e)))))));case 9:return l(s(p(a(o(r(t(n(e))))))));default:{let y=arguments[0];for(let h=1;h<arguments.length;h++)y=arguments[h](y);return y}}}function q(e,n,t,r,o,a,p,s,l){switch(arguments.length){case 1:return e;case 2:return function(){return n(e.apply(this,arguments))};case 3:return function(){return t(n(e.apply(this,arguments)))};case 4:return function(){return r(t(n(e.apply(this,arguments))))};case 5:return function(){return o(r(t(n(e.apply(this,arguments)))))};case 6:return function(){return a(o(r(t(n(e.apply(this,arguments))))))};case 7:return function(){return p(a(o(r(t(n(e.apply(this,arguments)))))))};case 8:return function(){return s(p(a(o(r(t(n(e.apply(this,arguments))))))))};case 9:return function(){return l(s(p(a(o(r(t(n(e.apply(this,arguments)))))))))}}}const L=S,T=e=>typeof e=="object"&&e!==null,F=e=>T(e)||L(e),O=e=>Object.keys(e),W=e=>Array.isArray(e)?e:Array.from(e),B=_(2,(e,n)=>e.map(n)),b=_(2,(e,n)=>W(e).join(n)),U=_(2,(e,n)=>e+n),E=e=>e.toUpperCase(),c=e=>e.length===0?e:E(e[0])+e.slice(1),w=_(e=>F(e[0]),(e,...n)=>{const t={...e};for(const r of n)delete t[r];return t}),M=(e,n)=>{const t=r=>e(r);return Object.assign(t,e,{displayName:n}),t},J=([e,n])=>t=>`${e}${t}${n}`,V=e=>n=>U(e,n),Y=(e,n=e)=>t=>(e.displayName=t(n.displayName??n.name),e),m=(e,n=e)=>t=>i([`${t}(`,")"],J,Y(e,n)),z=q(O,B(c),b("")),v=(e,n)=>(t,r)=>{const o=r===void 0?()=>`unfoldProp${c(n)}`:r;return i(t,B(p=>g(e,n)(p,o(p))))},g=(e,n)=>(t,r)=>{const o=a=>u.jsx(e,{...a,[n]:t});return i(r??`assumeProp${c(n)}`,m(o,e))},N=e=>(n,t)=>{const r=o=>{const a={...n,...o};return u.jsx(e,{...a})};return i(t??i(n,z,V("assumeProps")),m(r,e))};try{v.displayName="unfoldProp",v.__docgenInfo={description:`Unfold the given component into a component per member of the given union,
where the given prop of each component is partially applied to a different
member of the union.

This code:

\`\`\`tsx
const [GreenLabel, YellowLabel, RedLabel] = [
  assumeProp(BaseLabel, 'color')('green'),
  assumeProp(BaseLabel, 'color')('yellow'),
  assumeProp(BaseLabel, 'color')('red'),
]
\`\`\`

Can be rewritten using \`unfoldProp\` as:

\`\`\`tsx
import {String} from 'effect'
import {unfoldProp} from 'react-compinators'

const [ GreenLabel, YellowLabel, RedLabel ] = unfoldProp(
  BaseLabel,                  // Base component.
  'color',                    // Prop that we will be setting.
)(
  ['green', 'yellow', 'red'], // Array of union members.
  String.capitalize,          // Optional function will be used to compute
                              // variant displayName from its \`color\` prop.
)
\`\`\``,displayName:"unfoldProp",props:{}}}catch{}try{g.displayName="assumeProp",g.__docgenInfo={description:"Just like {@link assumeProps} but for a single prop.",displayName:"assumeProp",props:{}}}catch{}try{N.displayName="assumeProps",N.__docgenInfo={description:"Partially apply a subset of given component props.",displayName:"assumeProps",props:{}}}catch{}const C=e=>n=>M(n,`requireProp${c(e)}(${n.displayName??n.name})`),A=(e,n)=>t=>i(t,d(r=>({...r,[e]:e in r?r[e]??n:n}),`withDefault${c(e)}`)),K=(e,n="renameProps")=>t=>i(t,d(o=>{const a={};for(const[p,s]of Object.entries(o))p in e?a[e[p]]=s:a[p]=o[p];return a},n)),I=(e,n,t=`renameProp${c(e)}${c(n)}`)=>r=>i(t,m(a=>{const p=a[e],s=w(e)(a),l={[n]:p,...s};return u.jsx(r,{...l})},r)),R=(e,n="omitProps")=>(...t)=>i(n,m(o=>u.jsx(e,{...w(...t)(o)}),e)),d=(e,n="mapProps")=>t=>i(n,m(o=>u.jsx(t,{...e(o)}),t)),D=(e,n,t=`mapProp${c(n)}`)=>r=>d(a=>Object.assign({[n]:e(a[n])},w(a,n)),t)(r),k=(e,n,t)=>r=>m(a=>u.jsx(r,{...a,[e]:n(a[e])}),r)(t??`modProp${c(e)}`),P=e=>(n,t)=>r=>m(a=>u.jsx(r,{...a,[e]:n(a[e])}),r)(t??`modProp${c(e)}`);try{RenameProps.displayName="RenameProps",RenameProps.__docgenInfo={description:"The type of props accepted by the target component when wrapping a component\nwith props `BaseProps` and a type-level record mapping target component prop\nnames to base component prop names, for any prop names that are renamed.",displayName:"RenameProps",props:{}}}catch{}try{RenameRestProps.displayName="RenameRestProps",RenameRestProps.__docgenInfo={description:"The props left over when omitting from `BaseProps` the props that will be\nrenamed according to `Map`.",displayName:"RenameRestProps",props:{}}}catch{}try{WithDefaultProp.displayName="WithDefaultProp",WithDefaultProp.__docgenInfo={description:"The type of props where `Prop` is required, after it has been made optional\nby providing a default.",displayName:"WithDefaultProp",props:{}}}catch{}try{WithRequiredProp.displayName="WithRequiredProp",WithRequiredProp.__docgenInfo={description:"The type of props where `Prop` is optional, after it has been converted into\na required prop.",displayName:"WithRequiredProp",props:{}}}catch{}try{C.displayName="requireProp",C.__docgenInfo={description:"Convert a component that takes an optional prop `prop` into a component where\nthe prop is required. The opposite of {@link withDefault}.",displayName:"requireProp",props:{}}}catch{}try{A.displayName="withDefault",A.__docgenInfo={description:`Convert a component that takes a required prop \`prop\` into a component where
the prop is optional by providing a default value. The opposite of {@link requireProp}.
When the returned component receives the prop, it will use it, but when none
is given it will use the default given here.`,displayName:"withDefault",props:{}}}catch{}try{I.displayName="renameProp",I.__docgenInfo={description:"Rename a single named prop.",displayName:"renameProp",props:{}}}catch{}try{R.displayName="omitProps",R.__docgenInfo={description:"Omit the given prop names from for the given component.",displayName:"omitProps",props:{}}}catch{}try{d.displayName="mapProps",d.__docgenInfo={description:"Lifts a function that maps the prop type `B` into the prop type `A`, into a\nfunction the maps a component of type `FC<A>` into a component of type\n`FC<B>`.\n\nThis is the opposite of how `map` works. For example, `Array.map` lifts:\n\n```ts\n(A ⇒ B) -into→ (Array<A> ⇒ Array<B>)\n```\n\nWhile `mapProps`, called`mapInput` in\n[`effect`](https://github.com/Effect-TS/effect/blob/c407726f79df4a567a9631cddd8effaa16b3535d/packages/effect/src/Predicate.ts#L92),\nand [`contramap` in `@effect/typeclass`](https://github.com/Effect-TS/effect/blob/main/packages/typeclass/src/Contravariant.ts#L13),\n(“contra” means “counter to” in greek), is of type:\n\n```ts\n(B ⇒ A) -into→ (FC<A> ⇒ FC<B>)\n```\n\nUseful when:\n\n1. You have a component that takes props of type `A`.\n2. But you want a component that takes props of type `B`.\n3. And the props you have are of type `B`.\n4. But you do have some way of converting `B` ⇒ `A`.\n\nFor example:\n\n```tsx\nimport {mapProps} from 'react-compinators'\ninterface B { foo: string }\ninterface A { bar: number }\n\nconst ComponentA: FC<A> = ({ bar }) => <div>{bar + 1}</div>;\n\n// The function mapping B ⇒ A\nconst mapper = (a: B): A => ({ bar: a.foo.length })\n\n// We now have a component of B\nconst ComponentB: FC<B> = pipe(ComponentA, mapProps(mapper));\n```",displayName:"mapProps",props:{}}}catch{}try{D.displayName="mapProp",D.__docgenInfo={description:"Just like `mapProps` but for a single prop. The component will be given its\nprops unmodified, except for a single prop where the value will be the result\nof the given function. The given function is given the original prop value.",displayName:"mapProp",props:{}}}catch{}try{k.displayName="modProp",k.__docgenInfo={description:`Modify the props input of the given component by applying a function of type
\`<A>(a: A) => A\` over a named prop value. Useful when you can compute the new
value from the old one and nothing else, and you do not need to change the
prop type.`,displayName:"modProp",props:{}}}catch{}try{P.displayName="modOptionalProp",P.__docgenInfo={description:"Just like `modProp` but for _optional_ props.",displayName:"modOptionalProp",props:{}}}catch{}const f=(e,n)=>t=>i(t,P("style")(e,n)),j=e=>f(n=>({...n,...e})),x=e=>f(n=>({...e,...n})),$=(e,n)=>f(t=>{const r=`--${e}`;return{...t,[r]:n(t===void 0||!(r in t)?void 0:t[r])}});try{f.displayName="modStyle",f.__docgenInfo={description:"Apply a transform to the `style` prop of a component.",displayName:"modStyle",props:{}}}catch{}try{j.displayName="withStyle",j.__docgenInfo={description:"Merge the given styles, overriding the keys given in component props.",displayName:"withStyle",props:{}}}catch{}try{x.displayName="withDefaultStyle",x.__docgenInfo={description:`Merge the given styles only if styles are not in props, thus providing
defaults.`,displayName:"withDefaultStyle",props:{}}}catch{}try{$.displayName="modCssVar",$.__docgenInfo={description:"Apply a transform to the named CSS variable found in the `style` prop of a\ncomponent.",displayName:"modCssVar",props:{}}}catch{}export{N as a,g as b,f as c,x as d,c as e,k as f,U as g,D as h,K as i,M as j,d as m,R as o,i as p,I as r,v as u,j as w};
