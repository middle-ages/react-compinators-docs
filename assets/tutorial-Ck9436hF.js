import{j as e}from"./jsx-runtime-D_zvdyIk.js";import{useMDXComponents as r}from"./index-CePRvBtH.js";import{U as j}from"./index-F0qYugOv.js";import{a as h,b as c,u,p as i,o as g,c as f,w as b,d as y,e as w,f as x,g as v,m as P,h as L,r as m,i as C}from"./style-Dm7PnSSD.js";import{w as B}from"./index-Bdu921Hh.js";import"./index-DmM0KDA7.js";import"./iframe-B1fMAu0p.js";import"./index-nLeaPAJ8.js";import"./index-CXQShRbs.js";import"./index-DrFu-skq.js";const S=["red","yellow","green"],s=({text:n,color:o})=>{const t={div:"div",...r()};return e.jsx(t.div,{style:{background:o,textAlign:"center"},children:n})},N=h(s)({color:"yellow"}),A=h(s)({color:"yellow"},"Yellow"),k=c(s,"color")("yellow","My"),W=c(s,"color")("green"),Y=c(s,"color")("yellow"),H=c(s,"color")("red"),[R,O,T]=u(s,"color")(S,w),l=B(s)({default:{text:"Hello World!"},Red:{color:"red"},Yellow:{color:"yellow"},Green:{color:"green"}}),G=i(s,x("text",v("?"))),D=({bar:n})=>{const o={div:"div",...r()};return e.jsx(o.div,{children:n.toString()})},I=n=>({bar:n.foo.length}),F=i(D,P(I)),V=({foo:n})=>{const o={div:"div",...r()};return e.jsx(o.div,{children:n.toString()})},_=n=>n.length,M=i(V,L(_,"foo")),E=({text:n})=>{const o={div:"div",...r()};return e.jsx(o.div,{children:n})},Q=g(E,"OmitNumber")("number"),U=n=>e.jsx(Q,{...n}),z=i(s,m("textColor","color")),q=i(s,C({textColor:"color",value:"text"})),X=({text:n,style:o})=>{const t={div:"div",...r()};return e.jsx(t.div,{style:o,children:n})},d=f((n={background:"yellow"})=>({background:n.background==="red"?"green":n.background==="green"?"red":"yellow"}))(X),$=({text:n,style:o})=>{const t={div:"div",...r()};return e.jsx(t.div,{style:o,children:n})},J=b({color:"white",background:"black"})($),K=({text:n,style:o})=>{const t={div:"div",...r()};return e.jsx(t.div,{style:o,children:n})},Z=y({color:"white",background:"black"})(K),ee=({text:n})=>{const o={div:"div",...r()};return e.jsx(o.div,{children:n})},oe=i(ee,x("text",n=>`${n}?`),m("value","text"));function p(n){const o={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",...r(),...n.components};return l||a("Label1",!1),l.Green||a("Label1.Green",!0),l.Red||a("Label1.Red",!0),l.Yellow||a("Label1.Yellow",!0),e.jsxs(j,{children:[e.jsxs("h1",{children:[e.jsx("span",{style:{fontFamily:"Times New Roman, Times, serif"},children:"λ⚛"})," React Compinators Tutorial"]}),e.jsxs("ol",{children:[e.jsx("li",{children:e.jsx("a",{href:"#running-example",children:e.jsx("code",{children:"Running Example"})})}),e.jsx("li",{children:e.jsx("a",{href:"#assume",children:e.jsx("code",{children:"Assume"})})}),e.jsxs("ol",{children:[e.jsxs("li",{children:[e.jsx("a",{href:"#1-assumeprops",children:e.jsx("code",{children:"assumeProps"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/assumeProps.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#2-assumeprop",children:e.jsx("code",{children:"assumeProp"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/assumeProp.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#3-unfoldprop",children:e.jsx("code",{children:"unfoldProp"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/unfoldProp.html",children:"API"}),")"]})]}),e.jsx("li",{children:e.jsx("a",{href:"#variants",children:e.jsx("code",{children:"Variants"})})}),e.jsx("ol",{children:e.jsxs("li",{children:[e.jsx("a",{href:"#1-withvariants",children:e.jsx("code",{children:"withVariants"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/withVariants.html",children:"API"}),")"]})}),e.jsx("li",{children:e.jsx("a",{href:"#map",children:e.jsx("code",{children:"Map"})})}),e.jsxs("ol",{children:[e.jsxs("li",{children:[e.jsx("a",{href:"#1-modprop",children:e.jsx("code",{children:"modProp"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/modProp.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#2-mapprops",children:e.jsx("code",{children:"mapProps"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/mapProps.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#3-mapprop",children:e.jsx("code",{children:"mapProp"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/mapProp.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#4-omitprops",children:e.jsx("code",{children:"mapProps"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/omitProps.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#5-renameprop",children:e.jsx("code",{children:"renameProp"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/renameProp.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#6-renameprops",children:e.jsx("code",{children:"renameProps"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/renameProps.html",children:"API"}),")"]})]}),e.jsx("li",{children:e.jsx("a",{href:"#style",children:e.jsx("code",{children:"Style"})})}),e.jsxs("ol",{children:[e.jsxs("li",{children:[e.jsx("a",{href:"#1-modstyle",children:e.jsx("code",{children:"modStyle"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/modStyle.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#2-withstyle",children:e.jsx("code",{children:"withStyle"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/withStyle.html",children:"API"}),")"]}),e.jsxs("li",{children:[e.jsx("a",{href:"#3-withdefaultstyle",children:e.jsx("code",{children:"withDefaultStyle"})})," (",e.jsx("a",{href:"https://middle-ages.github.io/react-compinators-docs/docs/functions/withDefaultStyle.html",children:"API"}),")"]})]}),e.jsx("li",{children:e.jsx("a",{href:"#composition",children:"Composition"})}),e.jsx("li",{children:e.jsxs("a",{href:"#a-note-about-displayname",children:["A note about ",e.jsx("code",{children:"displayName"})]})})]}),e.jsx(o.h2,{id:"running-example",children:"Running Example"}),e.jsx(o.p,{children:"A simple label component we will use as a running example:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`export const COLORS = ['red', 'yellow', 'green'] as const
export type Color = (typeof COLORS)[number]

interface LabelProps {text: string color: Color}

const BaseLabel = ({text, color: background}: LabelProps) => (
  <div style={{background}}>{text}</div>
)

<BaseLabel text="Green"  color="green" />
<BaseLabel text="Yellow" color="yellow" />
<BaseLabel text="Red"    color="red" />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:"Three Labels"}),e.jsx(s,{text:"Green",color:"green"}),e.jsx(s,{text:"Yellow",color:"yellow"}),e.jsx(s,{text:"Red",color:"red"})]}),e.jsx(o.h2,{id:"the-combinators",children:"The Combinators"}),e.jsx(o.h3,{id:"assume",children:"Assume"}),e.jsx(o.p,{children:"Functions for partially applying props to components."}),e.jsxs(o.h4,{id:"1-assumeprops",children:["1. ",e.jsx(o.code,{children:"assumeProps"})]}),e.jsxs(o.p,{children:["To partially apply a subset of the ",e.jsx(o.code,{children:"<BaseLabel>"}),` props, we can use
`,e.jsx(o.code,{children:"assumeProps"}),"(",e.jsx(o.em,{children:"base"}),")(partial props):"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {assumeProps} from 'react-compinators'

const YellowLabel = assumeProps(BaseLabel)({color: 'yellow'})

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // assumePropsColor(BaseLabel)
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:"assumePropsColor(BaseLabel)"}),e.jsx(N,{text:"Hello World!"})]}),e.jsxs(o.p,{children:["By default, the ",e.jsx(o.code,{children:"displayName"}),` shown in React Dev Tools will be
`,e.jsx(o.code,{children:"assumeColor(BaseLabel)"}),", because ",e.jsx(o.code,{children:"BaseLabel"})," is the ",e.jsx(o.code,{children:"displayName"}),` of the base
component and we are partially applying a single prop called `,e.jsx(o.code,{children:"color"}),"."]}),e.jsxs(o.p,{children:["The combinators in this library will let you set an optional ",e.jsx(o.code,{children:"displayName"}),` to
aid debugging, but having none, will try to compute a reasonable value from
their arguments.`]}),e.jsxs(o.p,{children:["To override the ",e.jsx(o.code,{children:"displayName"})," ",e.jsx(o.em,{children:"wrapper"}),` we can provide the second, optional
argument to `,e.jsx(o.code,{children:"assumeProps"}),":"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {assumeProps} from 'react-compinators'

const YellowLabel = assumeProps(BaseLabel)({color: 'yellow'}, 'Yellow')
//                                                       ↑
//                  Optional argument for displayName wrapper 

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // Yellow(BaseLabel)
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:"Yellow(BaseLabel)"}),e.jsx(A,{text:"Hello World!"})]}),e.jsxs(o.p,{children:["This is how it looks in React Dev Tools with a default ",e.jsx(o.code,{children:"displayName"}),":"]}),e.jsx("img",{src:"https://middle-ages.github.io/react-compinators-docs/docs/dev-tools-display-name-default.png",alt:"Dev Tools default displayName",style:{border:"2px inset",maxWidth:"20rem"}}),e.jsxs(o.p,{children:["But when we provide the ",e.jsx(o.code,{children:"Yellow"})," argument to ",e.jsx(o.code,{children:"assumeProps"})," we get:"]}),e.jsx("img",{src:"https://middle-ages.github.io/react-compinators-docs/docs/dev-tools-display-name-custom.png",alt:"Dev Tools custom displayName",style:{border:"2px inset",maxWidth:"20rem"}}),e.jsxs(o.p,{children:[`All combinators follow this pattern of taking an optional value that will
determine `,e.jsx(o.code,{children:"displayName"}),"."]}),e.jsxs(o.h4,{id:"2-assumeprop",children:["2. ",e.jsx(o.code,{children:"assumeProp"})]}),e.jsxs(o.p,{children:["When you need to partially apply only a single prop, ",e.jsx(o.code,{children:"assumeProp"}),` is a simpler
variant of `,e.jsx(o.code,{children:"assume"}),". Note that it takes an optional ",e.jsx(o.code,{children:"displayName"}),` argument as
well:`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {assumeProp} from 'react-compinators'

const YellowLabel = assumeProp(BaseLabel, 'color')('yellow', 'My')

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // My(BaseLabel)
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:"My(BaseLabel)"}),e.jsx(k,{text:"Hello World!"})]}),e.jsxs(o.h4,{id:"3-unfoldprop",children:["3. ",e.jsx(o.code,{children:"unfoldProp"})]}),e.jsxs(o.p,{children:["What if we wanted to partially apply ",e.jsx(o.em,{children:"three"}),` variants of the button, one for
each color?`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {assumeProp} from 'react-compinators'

export const GreenLabel  = assumeProp(BaseLabel, 'color')('green')
export const YellowLabel = assumeProp(BaseLabel, 'color')('yellow')
export const RedLabel    = assumeProp(BaseLabel, 'color')('red')

<RedLabel    text="Red"/>
<YellowLabel text="Yellow"/>
<GreenLabel  text="Green"/>
`})}),e.jsxs("fieldset",{children:[e.jsxs("legend",{children:["Calling ",e.jsx("code",{children:"assumeProp"})," ",e.jsx("i",{children:"three"})," times"]}),e.jsx(W,{text:"Green"}),e.jsx(Y,{text:"Yellow"}),e.jsx(H,{text:"Red"})]}),e.jsxs(o.p,{children:["We could loop over the values, or we could use the ",e.jsx(o.code,{children:"unfoldProp"}),` combinator.
It supports the common use case of creating a `,e.jsx(o.em,{children:"variant per union member"}),`, useful
when we prefer `,e.jsx(o.em,{children:"more components but fewer props"}),", over ",e.jsx(o.em,{children:`fewer props but more
components`}),":"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {String} from 'effect'
import {unfoldProp} from 'react-compinators'

const [ GreenLabel, YellowLabel, RedLabel ] = unfoldProp(
  BaseLabel,         // Base component.
  'color',           // Prop that we will be setting.
)(
  COLORS,            // Array of union members.
  String.capitalize, // Optional function will be used to compute variant
                     // displayName from its \`color\` prop.
) 

<RedLabel    text="Red"/>
<YellowLabel text="Yellow"/>
<GreenLabel  text="Green"/>

console.log(YellowLabel.displayName) // Yellow(BaseLabel)
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"unfoldProp"})}),e.jsx(R,{text:"Green"}),e.jsx(O,{text:"Yellow"}),e.jsx(T,{text:"Red"})]}),e.jsx(o.h3,{id:"variants",children:"Variants"}),e.jsx(o.p,{children:"Functions for building component variants."}),e.jsxs(o.h4,{id:"1-withvariants",children:["1. ",e.jsx(o.code,{children:"withVariants"})]}),e.jsxs(o.p,{children:[`When building a family of variants from a base component, besides building the
various variants, there is the issue of `,e.jsx(o.em,{children:"import ergonomics"}),"."]}),e.jsxs(o.p,{children:[`Every variant must be exported and then imported. A common cure is adding the variants as
`,e.jsx(o.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Expando",rel:"nofollow",children:"expando"}),` props to
the component function.`]}),e.jsx(o.p,{children:"Now instead of:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {Label, GreenLabel, YellowLabel, RedLabel} from 'Label'
`})}),e.jsx(o.p,{children:"Clients can import:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {Label} from 'Label'
`})}),e.jsxs(o.p,{children:["And access the variants as props of the ",e.jsx(o.code,{children:"<Label>"}),` component, for example to
access the `,e.jsx(o.code,{children:"Green"})," variant:"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`<Label.Green text="Hello World!"/>
`})}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"withVariants"}),` help reduce the boilerplate required by the component author
to achieve this `,e.jsx(o.em,{children:"import ergonomics"}),`. You define your variants and get back a
single symbol you can export. All variants will be present as expando props, and
the component itself will be customized to the given spec given under the
`,e.jsx(o.code,{children:"default"})," key."]}),e.jsxs(o.p,{children:["Here is how we could export the ",e.jsx(o.code,{children:"<BaseLabel>"}),` variants, one per color, and
partially apply the label so it shows `,e.jsx(o.code,{children:"Hello World!"}),` and only lets the user
change `,e.jsx(o.code,{children:"color"}),":"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`// Label.tsx
import {withVariants} from 'react-compinators'

export const Label = withVariants(BaseLabel)({
  // A data structure that defines four components
  default: {text:  'Hello World!'},
  Red:     {color: 'red'},
  Yellow:  {color: 'yellow'},
  Green:   {color: 'green'},
})
`})}),e.jsx(o.p,{children:"Then import and use with:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {Label} from 'Label'

<Label color='green'/>
<Label.Red text="red"/>
<Label.Yellow text="yellow"/>
<Label.Green text="green"/>

`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsxs("code",{children:[e.jsx("i",{children:"Four"})," variants from a single object"]})}),e.jsx(l,{color:"green"}),e.jsx(l.Red,{text:"red"}),e.jsx(l.Yellow,{text:"yellow"}),e.jsx(l.Green,{text:"green"})]}),e.jsx(o.h3,{id:"map",children:"Map"}),e.jsx(o.p,{children:"Functions for mapping over component props."}),e.jsxs(o.h4,{id:"1-modprop",children:["1. ",e.jsx(o.code,{children:"modProp"})]}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"modProp"}),` is used to map over a component prop without changing its type.The
returned component will be of the same type as the base component.`]}),e.jsxs(o.p,{children:[`Useful for example to add a CSS class to the a component without creating a new
component, and without changing the component props at its call site. In this
case it would act like `,e.jsx(o.code,{children:"assumeProp"}),`, except instead of fixing a prop value, we
are `,e.jsx(o.em,{children:"adding"})," a fixed value to the prop."]}),e.jsx(o.p,{children:"Here we convert our label into one that appends a question mark to the text:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {String, pipe} from 'effect'
import {modProp} from 'react-compinators'

const QuestionLabel: typeof BaseLabel = pipe(
  '?',
  String.concat,
  modProp(BaseLabel,'text'),
)

<QuestionLabel color="yellow" text="Hello World" />

console.log(QuestionLabel.displayName) // mapPropText(BaseLabel)
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"modPropText(BaseLabel)"})}),e.jsx(G,{color:"yellow",text:"Hello World"})]}),e.jsxs(o.h4,{id:"2-mapprops",children:["2. ",e.jsx(o.code,{children:"mapProps"})]}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"modProps"})," is actually a special case of ",e.jsx(o.code,{children:"mapProps"}),", useful when:"]}),e.jsxs(o.ol,{children:[`
`,e.jsxs(o.li,{children:["You have a component that takes props of type ",e.jsx(o.code,{children:"A"}),"."]}),`
`,e.jsxs(o.li,{children:["But you want a component that takes props of type ",e.jsx(o.code,{children:"B"}),"."]}),`
`,e.jsxs(o.li,{children:["And the props you have are of type ",e.jsx(o.code,{children:"B"}),"."]}),`
`,e.jsxs(o.li,{children:["But you do have some way of converting ",e.jsx(o.code,{children:"B"})," ⇒ ",e.jsx(o.code,{children:"A"}),"."]}),`
`]}),e.jsx(o.p,{children:`For example let's convert a component that display a number into a component
that displays character count for a given string:`}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {mapProps} from 'react-compinators'
interface B { foo: string }
interface A { bar: number }

const ComponentA: FC<A> = ({ bar }) => <div>{bar.toString()}</div>;

// The function mapping B ⇒ A
const mapper = (a: B): A => ({ bar: a.foo.length })

// We now have a component of B
const ComponentB: FC<B> = pipe(ComponentA, mapProps(mapper));

<ComponentB foo="Hello World!">
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"mapProps(ComponentA)"})}),e.jsx(F,{foo:"Hello World!"})]}),e.jsxs(o.p,{children:["In this case we are renaming a prop and changing prop type, but ",e.jsx(o.code,{children:"mapProps"}),` can
do anything as long as the types fit.`]}),e.jsxs(o.h4,{id:"3-mapprop",children:["3. ",e.jsx(o.code,{children:"mapProp"})]}),e.jsxs(o.p,{children:["When you don't need the full power of ",e.jsx(o.code,{children:"mapProps"}),`, map prop focuses on a single
named prop, and can only change its value but `,e.jsx(o.em,{children:"not"})," the prop name."]}),e.jsx(o.p,{children:`Here is the example of converting a component that displays numbers into one
that display character count, but here the prop name is the same between base
component and the one returned:`}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {mapProp} from 'react-compinators'
interface B { foo: string }
interface A { foo: number }

const ComponentA: FC<A> = ({foo}) => <div>{foo.toString()}</div>;
const mapper            = (foo: string): number => foo.length
const ComponentB: FC<B> = pipe(ComponentA, mapProp(mapper, 'foo'));

<ComponentB foo="Hello World!">
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"mapProp(ComponentA)"})}),e.jsx(M,{foo:"Hello World!"})]}),e.jsxs(o.h4,{id:"4-omitprops",children:["4. ",e.jsx(o.code,{children:"omitProps"})]}),e.jsxs(o.p,{children:[`When a parent component spreads its props to its children, there is usually some
prop massaging required. When this requires `,e.jsx(o.em,{children:"removal"}),` of props by name, you can
convert your component into one that drops these props using `,e.jsx(o.code,{children:"omitProps"}),"."]}),e.jsxs(o.p,{children:["In the code below, the ",e.jsx(o.code,{children:"<Parent>"}),` component takes a pair of props while its
child gets only a single prop. Instead of manipulating the props object, we
convert the child into one that ignores the extra prop:`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {omitProps} from 'react-compinators'

interface ParentProps {text: string; number: number}
interface ChildProps _{text: string}

const Child = ({text}: ChildProps) => <div>{text}</div>

const OmitNumber = omitProps(Child, 'OmitNumber')('number')

// No need to filter props: child is wrapped in a HOC that will
// discard the extra prop.
const Parent = (props: ParentProps) => (<OmitNumber {...props} >)

<Parent text="Hello World!" number={123} />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"Parent » OmitNumber(Child)"})}),e.jsx(U,{text:"Hello World!",number:123})]}),e.jsxs(o.h4,{id:"5-renameprop",children:["5. ",e.jsx(o.code,{children:"renameProp"})]}),e.jsxs(o.p,{children:[`Don't you hate it when you have the correct component, and the correct props,
all except for a prop that is named differently? A couple of these can easily
degrade a nice one-line function into a multiline mess of prop destructuring and
massaging. Sometimes it is easier to change the `,e.jsx(o.em,{children:"component"}),` so it will accept
the renamed prop. `,e.jsx(o.code,{children:"renameProp"}),` takes a pair of names, one for the old and one
for the new, and rename the prop in the given component:`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`// Unfortunately, NOT BaseLabel props.
const props = {text: 'Hello World!', textColor: 'green'}

// The BaseLabel component with its color prop renamed to textColor.
const Component = pipe(BaseLabel, renameProp('textColor', 'color'))

// Now we can use our props, even if the prop name is wrong.
<Component {...props} />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"renamePropTextColorColor(BaseLabel)"})}),e.jsx(z,{textColor:"green",text:"Hello World!"})]}),e.jsxs(o.h4,{id:"6-renameprops",children:["6. ",e.jsx(o.code,{children:"renameProps"})]}),e.jsx(o.p,{children:"When you need to rename several props:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`// Unfortunately, all prop names are wrong.
const props = {textColor: 'green', value: 'Hello World!'}

// So we rename them on the component.
const Component = pipe(
  BaseLabel,
  renameProps({textColor: 'color', value: 'text'}),
)

<Component {...props} />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"renameProps(BaseLabel)"})}),e.jsx(q,{textColor:"green",value:"Hello World!"})]}),e.jsx(o.h3,{id:"style",children:"Style"}),e.jsx(o.p,{children:"Functions for modifying the component style via its props."}),e.jsxs(o.h4,{id:"1-modstyle",children:["1. ",e.jsx(o.code,{children:"modStyle"})]}),e.jsxs(o.p,{children:["The combinators in the ",e.jsx(o.code,{children:"style"})," module specialize ",e.jsx(o.code,{children:"modProp"}),` for components that
accept a `,e.jsx(o.code,{children:"style"})," prop of type ",e.jsx(o.a,{href:"https://react.dev/learn/typescript#typing-style-props",rel:"nofollow",children:"CSSProperties"}),"."]}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"modStyle"})," will let you run a function over the incoming ",e.jsx(o.code,{children:"style"}),` prop of a
component. For example if we have a styled label:`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {CssProperties} from 'react'

interface StyledProps {
  text: string
  style?: CSSProperties
}

const Styled = ({text, style}: StyledProps) => (<div {...{style}}>{text}</div>)
`})}),e.jsxs(o.p,{children:["We can transform it so that if the ",e.jsx(o.code,{children:"background"})," style is ",e.jsx(o.code,{children:"red"}),` we will turn it
`,e.jsx(o.code,{children:"green"})," and vice versa, and if there is no such style we set it to ",e.jsx(o.code,{children:"yellow"}),":"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`const Flipped = modStyle((style = {background: 'yellow'})  => ({
  color:
    style.background === 'red'
      ? 'green'
      : style.background === 'green'
        ? 'red'
        : 'yellow',

}))(Styled)

<Flipped text="red" style={{background: 'green'}} />
<Flipped text="green" style={{background: 'red'}} />
<Flipped text="yellow" />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"modStyle"})}),e.jsx(d,{text:"red",style:{background:"green"}}),e.jsx(d,{text:"green",style:{background:"red"}}),e.jsx(d,{text:"yellow"})]}),e.jsxs(o.h4,{id:"2-withstyle",children:["2. ",e.jsx(o.code,{children:"withStyle"})]}),e.jsxs(o.p,{children:["When you just need to ",e.jsx(o.em,{children:"add"})," or ",e.jsx(o.em,{children:"override"}),` style, you can use this specialization of
`,e.jsx(o.code,{children:"modStyle"}),":"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {withStyle} from 'react-compinators'

const Styled = ({text, style}) => (<div {...{style}}>{text}</div>)

const BrightOnDark = withStyle({color: 'white', background: 'black'})(Styled)

// “yellow” will be replaced by “white”
<BrightOnDark text="Hello World!" style={{color: 'yellow'}} />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"withStyle"})}),e.jsx(J,{text:"Hello World!",style:{color:"yellow"}})]}),e.jsxs(o.h4,{id:"3-withdefaultstyle",children:["3. ",e.jsx(o.code,{children:"withDefaultStyle"})]}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"withDefaultStyle"})," is the opposite of ",e.jsx(o.code,{children:"withStyle"}),`, in that given styles are
merged with `,e.jsx(o.em,{children:"lowest"})," priority. Useful for setting default styles:"]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {withDefaultStyle} from 'react-compinators'

const Styled = ({text, style}) => (<div {...{style}}>{text}</div>)

const BrightOnDark = withDefaultStyle({color: 'white', background: 'black'})(Styled)

// “yellow” will override “white”
<BrightOnDark text="Hello World!" style={{color: 'yellow'}} />
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:e.jsx("code",{children:"withStyle"})}),e.jsx(Z,{text:"Hello World!",style:{color:"yellow"}})]}),e.jsx(o.h3,{id:"composition",children:"Composition"}),e.jsx(o.p,{children:"The combinators can be composed as functions, for example in a pipe:"}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-tsx",children:`import {pipe} from 'effect'
import {modProp, renameProp} from 'react-compinators'

const TextLabel = ({text}) => <div>{text}</div>

const ValueQuestion = pipe(
  TextLabel,
  modProp('text', text => \`\${text}?\`),
  renameProp('value', 'text'),
);

<ValueQuestion value="What is your name">
`})}),e.jsxs("fieldset",{children:[e.jsx("legend",{children:"Composing Combinators"}),e.jsx(oe,{value:"What is your name"})]}),e.jsxs(o.h3,{id:"a-note-about-displayname",children:["A note about ",e.jsx(o.code,{children:"displayName"})]}),e.jsxs(o.p,{children:[e.jsx(o.code,{children:"displayName"}),` is used mostly for debugging via
`,e.jsx(o.a,{href:"https://react.dev/learn/react-developer-tools",rel:"nofollow",children:"React Dev Tools"}),`.
The convention for HOCs is:`]}),e.jsx(o.pre,{children:e.jsx(o.code,{className:"language-text",children:`Original Component Name
            ↓   
   Yellow(BaseLabel)
      ↑
  HOC Name
`})}),e.jsxs(o.p,{children:[`Read more about React Dev Tools and HOCs
`,e.jsx(o.a,{href:"https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#higher-order-components",rel:"nofollow",children:"here"}),"."]})]})}function he(n={}){const{wrapper:o}={...r(),...n.components};return o?e.jsx(o,{...n,children:e.jsx(p,{...n})}):p(n)}function a(n,o){throw new Error("Expected "+(o?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}export{s as BaseLabel,J as BrightOnDark1,Z as BrightOnDark2,S as COLORS,E as Child,z as Component1,q as Component2,D as ComponentA1,V as ComponentA2,F as ComponentB1,M as ComponentB2,d as Flipped,W as GreenLabel4,R as GreenLabel5,l as Label1,Q as OmitNumber,U as Parent,G as QuestionLabel,H as RedLabel4,T as RedLabel5,X as Styled1,$ as Styled2,K as Styled3,ee as TextLabel,oe as ValueQuestion,N as YellowLabel1,A as YellowLabel2,k as YellowLabel3,Y as YellowLabel4,O as YellowLabel5,he as default,I as mapper1,_ as mapper2};
