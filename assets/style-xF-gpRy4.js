import{j as u}from"./jsx-runtime-D_zvdyIk.js";const S=e=>typeof e=="function",f=function(e,t){if(typeof e=="function")return function(){return e(arguments)?t.apply(this,arguments):n=>t(n,...arguments)};switch(e){case 0:case 1:throw new RangeError(`Invalid arity ${e}`);case 2:return function(n,r){return arguments.length>=2?t(n,r):function(o){return t(o,n)}};case 3:return function(n,r,o){return arguments.length>=3?t(n,r,o):function(p){return t(p,n,r)}};case 4:return function(n,r,o,p){return arguments.length>=4?t(n,r,o,p):function(a){return t(a,n,r,o)}};case 5:return function(n,r,o,p,a){return arguments.length>=5?t(n,r,o,p,a):function(s){return t(s,n,r,o,p)}};default:return function(){if(arguments.length>=e)return t.apply(this,arguments);const n=arguments;return function(r){return t(r,...n)}}}};function i(e,t,n,r,o,p,a,s,l){switch(arguments.length){case 1:return e;case 2:return t(e);case 3:return n(t(e));case 4:return r(n(t(e)));case 5:return o(r(n(t(e))));case 6:return p(o(r(n(t(e)))));case 7:return a(p(o(r(n(t(e))))));case 8:return s(a(p(o(r(n(t(e)))))));case 9:return l(s(a(p(o(r(n(t(e))))))));default:{let h=arguments[0];for(let y=1;y<arguments.length;y++)h=arguments[y](h);return h}}}function T(e,t,n,r,o,p,a,s,l){switch(arguments.length){case 1:return e;case 2:return function(){return t(e.apply(this,arguments))};case 3:return function(){return n(t(e.apply(this,arguments)))};case 4:return function(){return r(n(t(e.apply(this,arguments))))};case 5:return function(){return o(r(n(t(e.apply(this,arguments)))))};case 6:return function(){return p(o(r(n(t(e.apply(this,arguments))))))};case 7:return function(){return a(p(o(r(n(t(e.apply(this,arguments)))))))};case 8:return function(){return s(a(p(o(r(n(t(e.apply(this,arguments))))))))};case 9:return function(){return l(s(a(p(o(r(n(t(e.apply(this,arguments)))))))))}}}const F=S,W=e=>typeof e=="object"&&e!==null,B=e=>W(e)||F(e),O=e=>Object.keys(e),U=e=>Array.isArray(e)?e:Array.from(e),q=f(2,(e,t)=>e.map(t)),E=f(2,(e,t)=>U(e).join(t)),M=f(2,(e,t)=>e+t),J=e=>e.toUpperCase(),c=e=>e.length===0?e:J(e[0])+e.slice(1),v=f(e=>B(e[0]),(e,...t)=>{const n={...e};for(const r of t)delete n[r];return n}),L=([e,t])=>n=>`${e}${n}${t}`,V=e=>t=>M(e,t),z=(e,t=e)=>n=>(e.displayName=n(t.displayName??t.name),e),m=(e,t=e)=>n=>i([`${n}(`,")"],L,z(e,t)),Y=T(O,q(c),E("")),w=(e,t)=>(n,r)=>{const o=r===void 0?()=>`unfoldProp${c(t)}`:r;return i(n,q(a=>g(e,t)(a,o(a))))},g=(e,t)=>(n,r)=>{const o=p=>u.jsx(e,{...p,[t]:n});return i(r??`assumeProp${c(t)}`,m(o,e))},N=e=>(t,n)=>{const r=o=>{const p={...t,...o};return u.jsx(e,{...p})};return i(n??i(t,Y,V("assumeProps")),m(r,e))};try{w.displayName="unfoldProp",w.__docgenInfo={description:`Unfold the given component into a component per member of the given union,
where the given prop of each component is partially applied to a different
member of the union.`,displayName:"unfoldProp",props:{}}}catch{}try{g.displayName="assumeProp",g.__docgenInfo={description:"Just like {@link assumeProps} but for a single prop.",displayName:"assumeProp",props:{}}}catch{}try{N.displayName="assumeProps",N.__docgenInfo={description:"Partially apply a subset of given component props.",displayName:"assumeProps",props:{}}}catch{}const G=(e,t)=>{const n=r=>e(r);return Object.assign(n,e,{displayName:t}),n},C=e=>t=>G(t,`requireProp${c(e)}(${t.displayName??t.name})`),A=(e,t)=>n=>i(n,d(r=>({...r,[e]:e in r?r[e]??t:t}),`withDefault${c(e)}`)),K=(e,t="renameProps")=>n=>i(n,d(o=>{const p={};for(const[a,s]of Object.entries(o))a in e?p[e[a]]=s:p[a]=o[a];return p},t)),I=(e,t,n=`renameProp${c(e)}${c(t)}`)=>r=>i(n,m(p=>{const a=p[e],s=v(e)(p),l={[t]:a,...s};return u.jsx(r,{...l})},r)),D=(e,t="omitProps")=>(...n)=>i(t,m(o=>u.jsx(e,{...v(...n)(o)}),e)),d=(e,t="mapProps")=>n=>i(t,m(o=>u.jsx(n,{...e(o)}),n)),k=(e,t,n=`mapProp${c(t)}`)=>r=>d(p=>Object.assign({[t]:e(p[t])},v(p,t)),n)(r),R=(e,t,n)=>r=>m(p=>u.jsx(r,{...p,[e]:t(p[e])}),r)(n??`modProp${c(e)}`),P=e=>(t,n)=>r=>m(p=>u.jsx(r,{...p,[e]:t(p[e])}),r)(n??`modProp${c(e)}`);try{RenameProps.displayName="RenameProps",RenameProps.__docgenInfo={description:"The type of props accepted by the target component when wrapping a component\nwith props `BaseProps` and a type-level record mapping target component prop\nnames to base component prop names, for any prop names that are renamed.",displayName:"RenameProps",props:{}}}catch{}try{RenameRestProps.displayName="RenameRestProps",RenameRestProps.__docgenInfo={description:"The props left over when omitting from `BaseProps` the props that will be\nrenamed according to `Map`.",displayName:"RenameRestProps",props:{}}}catch{}try{WithDefaultProp.displayName="WithDefaultProp",WithDefaultProp.__docgenInfo={description:"The type of props where `Prop` is required, after it has been made optional\nby providing a default.",displayName:"WithDefaultProp",props:{}}}catch{}try{WithRequiredProp.displayName="WithRequiredProp",WithRequiredProp.__docgenInfo={description:"The type of props where `Prop` is optional, after it has been converted into\na required prop.",displayName:"WithRequiredProp",props:{}}}catch{}try{C.displayName="requireProp",C.__docgenInfo={description:"Convert a component that takes an optional prop `prop` into a component where\nthe prop is required. The opposite of {@link withDefault}.",displayName:"requireProp",props:{}}}catch{}try{A.displayName="withDefault",A.__docgenInfo={description:`Convert a component that takes a required prop \`prop\` into a component where
the prop is optional by providing a default value. The opposite of {@link requireProp}.
When the returned component receives the prop, it will use it, but when none
is given it will use the default given here.`,displayName:"withDefault",props:{}}}catch{}try{I.displayName="renameProp",I.__docgenInfo={description:"Rename a single named prop.",displayName:"renameProp",props:{}}}catch{}try{D.displayName="omitProps",D.__docgenInfo={description:"Omit the given prop names from for the given component.",displayName:"omitProps",props:{}}}catch{}try{d.displayName="mapProps",d.__docgenInfo={description:"Lifts a function that maps the prop type `B` into the prop type `A`, into a\nfunction the maps a component of type `FC<A>` into a component of type\n`FC<B>`.\n\nThis is the opposite of how `map` works. For example, `Array.map` lifts:\n\n```ts\n(A ⇒ B) -into→ (Array<A> ⇒ Array<B>)\n```\n\nWhile `mapProps`, called`mapInput` in\n[`effect`](https://github.com/Effect-TS/effect/blob/c407726f79df4a567a9631cddd8effaa16b3535d/packages/effect/src/Predicate.ts#L92),\nand [`contramap` in `@effect/typeclass`](https://github.com/Effect-TS/effect/blob/main/packages/typeclass/src/Contravariant.ts#L13),\n(“contra” means “counter to” in greek), is of type:\n\n```ts\n(B ⇒ A) -into→ (FC<A> ⇒ FC<B>)\n```\n\nUseful when:\n\n1. You have a component that takes props of type `A`.\n2. But you want a component that takes props of type `B`.\n3. And the props you have are of type `B`.\n4. But you do have some way of converting `B` ⇒ `A`.\n\nFor example:\n\n```tsx\nimport {mapProps} from 'react-compinators'\ninterface B { foo: string }\ninterface A { bar: number }\n\nconst ComponentA: FC<A> = ({ bar }) => <div>{bar + 1}</div>;\n\n// The function mapping B ⇒ A\nconst mapper = (a: B): A => ({ bar: a.foo.length })\n\n// We now have a component of B\nconst ComponentB: FC<B> = pipe(ComponentA, mapProps(mapper));\n```",displayName:"mapProps",props:{}}}catch{}try{k.displayName="mapProp",k.__docgenInfo={description:"Just like `mapProps` but for a single prop. The component will be given its\nprops unmodified, except for a single prop where the value will be the result\nof the given function. The given function is given the original prop value.",displayName:"mapProp",props:{}}}catch{}try{R.displayName="modProp",R.__docgenInfo={description:`Modify the props input of the given component by applying a function of type
\`<A>(a: A) => A\` over a named prop value. Useful when you can compute the new
value from the old one and nothing else, and you do not need to change the
prop type.`,displayName:"modProp",props:{}}}catch{}try{P.displayName="modOptionalProp",P.__docgenInfo={description:"Just like `modProp` but for _optional_ props.",displayName:"modOptionalProp",props:{}}}catch{}const _=(e,t)=>n=>i(n,P("style")(e,t)),j=e=>_(t=>({...t,...e})),$=e=>_(t=>({...e,...t})),x=(e,t)=>_(n=>{const r=`--${e}`,o=n===void 0?void 0:r in n?n[r]:void 0;return{...n,[r]:t(o)}});try{_.displayName="modStyle",_.__docgenInfo={description:"Apply a transform to the `style` prop of a component.",displayName:"modStyle",props:{}}}catch{}try{j.displayName="withStyle",j.__docgenInfo={description:"Merge the given styles, overriding the keys given in component props.",displayName:"withStyle",props:{}}}catch{}try{$.displayName="withDefaultStyle",$.__docgenInfo={description:`Merge the given styles only if styles are not in props, thus providing
defaults.`,displayName:"withDefaultStyle",props:{}}}catch{}try{x.displayName="modCssVar",x.__docgenInfo={description:"Apply a transform to the named CSS variable found in the `style` prop of a\ncomponent.",displayName:"modCssVar",props:{}}}catch{}export{N as a,g as b,_ as c,$ as d,c as e,R as f,M as g,k as h,K as i,G as j,d as m,D as o,i as p,I as r,w as u,j as w};
